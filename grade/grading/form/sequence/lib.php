<?php

/**
 * Grading method controller for the Sequence Plugin.
 */

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot.'/grade/grading/form/lib.php');
require_once($CFG->dirroot.'/lib/filelib.php');

const SEQUENCE = 'sequence';

/**
 * This controller encapsulates the sequence grading logic.
 */
class gradingform_sequence_controller extends gradingform_controller {

    public function extend_settings_navigation(settings_navigation $settingsnav, navigation_node $node = null)
    {
        $node->add(get_string('definesequence', 'gradingform_sequence'),
            $this->get_editor_url(), settings_navigation::TYPE_CUSTOM,
            null, null, new pix_icon('icon', '', 'gradingform_sequence')
        );
    }

    public function extend_navigation(global_navigation $navigation, navigation_node $node = null)
    {
        if (has_capability('moodle/grade:managegradingforms', $this->get_context())) {
            return;
        }
        if ($this->is_form_defined() && ($options = $this->get_options()) && !empty($options['alwaysshowdefinition'])) {
            $node->add(get_string('gradingof', 'gradingform_sequence', get_grading_manager($this->get_areaid())->get_area_title()),
                new moodle_url('/grade/grading/form/'. $this->get_method_name().'/preview.php', ['areaid' => $this->get_areaid()]),
                settings_navigation::TYPE_CUSTOM
            );
        }
    }

    /**
     * Saves the sequence definition into the database.
     * @param stdClass $definition
     * @param null $usermodified
     * @throws coding_exception
     */
    public function update_definition(stdClass $definition, $usermodified = null)
    {
        parent::update_definition($definition, $usermodified); // TODO: Change the autogenerated stub
    }

    public function render_preview(moodle_page $page)
    {
        // TODO: Implement render_preview() method.
    }

    protected function delete_plugin_definition()
    {
        // TODO: Implement delete_plugin_definition() method.
    }

    /**
     * Converts the current definition into an object suitable for the editor form's set_data()
     *
     * @param boolean $addemptycriterion whether to add an empty criterion if the rubric is completely empty (just being created)
     * @return stdClass
     */
    public function get_definition_for_editing($addemptycriterion = false) {
        $definition = $this->get_definition();
        $properties = new stdClass();
        $properties->areaid = $this->areaid;
        if ($definition) {
            foreach (array('id', 'name', 'description', 'descriptionformat', 'status') as $key) {
                $properties->$key = $definition->$key;
            }
            $options = self::description_form_field_options($this->get_context());
            $properties = file_prepare_standard_editor($properties, 'description', $options, $this->get_context(),
                'grading', 'description', $definition->id);
        }
        $properties->sequence = [
            'steps' => [],
            'options' => $this->get_options()
        ];
        //$properties->rubric = array('criteria' => array(), 'options' => $this->get_options());
        if (!empty($definition->sequence)) {
            $properties->sequence['steps'] = $definition->sequence;
        } else if (!$definition && $addemptycriterion) {
            $properties->sequence['steps'] = array('addcriterion' => 1);
        }

        return $properties;
    }

    /**
     * Options for displaying the rubric description field in the form
     *
     * @param object $context
     * @return array options for the form description field
     */
    public static function description_form_field_options($context) {
        global $CFG;
        return array(
            'maxfiles' => -1,
            'maxbytes' => get_user_max_upload_file_size($context, $CFG->maxbytes),
            'context'  => $context,
        );
    }

    /**
     * Returns the default options for the sequence display
     *
     * @return array
     */
    public static function get_default_options() {
        $options = array(
            'alwaysshowdefinition' => 1,
            'showdescriptionteacher' => 1,
            'showdescriptionstudent' => 1,
            'showscoreteacher' => 1,
            'showscorestudent' => 1,
            'enableremarks' => 1,
            'showremarksstudent' => 1
        );
        return $options;
    }
    /**
     * Gets the options of this rubric definition, fills the missing options with default values
     *
     * The only exception is 'lockzeropoints' - if other options are present in the json string but this
     * one is absent, this means that the rubric was created before Moodle 3.2 and the 0 value should be used.
     *
     * @return array
     */
    public function get_options()
    {
        $options = self::get_default_options();
        if (!empty($this->definition->options)) {
            $thisoptions = json_decode($this->definition->options, true); // Assoc. array is expected.
            foreach ($thisoptions as $option => $value) {
                $options[$option] = $value;
            }
        }
        return $options;
    }

}